***
***        Maude LTLR model checker.
***        Version 0.5.
***
*** Changes: now support a parameterized fairness
***


load model-checker

fmod STATE-SUBSTITUTION is
  protecting QID .
  sorts StateAssignment .
  --- assignment (_\_ Qid Value-> StateAssignItem) should defined by users

  sorts StateSubstitution .
  subsorts StateAssignment < StateSubstitution .
  op noSubstitution : -> StateSubstitution [ctor] .
  op _;_ : StateSubstitution StateSubstitution -> StateSubstitution
        [ctor comm assoc id: noSubstitution prec 65] .
  eq A:StateAssignment ; A:StateAssignment = A:StateAssignment .
endfm

fmod STATE-CONTEXT is
  sort StateContext .
  op noContext : -> StateContext [ctor] . 
  op [] : -> StateContext [ctor] .  --- context (hole) symbol
endfm

fmod PROOF-TERM is
  including STATE-SUBSTITUTION .
  including STATE-CONTEXT .
  sorts RuleName .
  subsorts Qid < RuleName .
  ops unlabeled : -> RuleName .

  sorts ProofTerm .
  op deadlock : -> ProofTerm [ctor format(r! o)] .
  op {_|_:_} : StateContext RuleName StateSubstitution -> ProofTerm [ctor format (c! o c r c y? c! o)] .

  --- abbrevations of proof term.
  op {_} : RuleName -> ProofTerm [ctor format (c! r c! o)] .
  op {_:_} : RuleName StateSubstitution -> ProofTerm [ctor format (c! r c y? c! o)] .
  op {_|_} : StateContext RuleName -> ProofTerm [ctor format (c! o c r c! o)] .
endfm

fmod ACTION-SATISFACTION is
  protecting PROOF-TERM .
  sorts Action .
  subsorts ProofTerm < Action .
  op tau : -> Action [ctor] .        --- empty action
  op _|=_ : ProofTerm Action -> Bool [frozen] .

  var P : ProofTerm . 
  var C : StateContext . var R : RuleName . var S : StateSubstitution .

---( the followings are not good for the param props...
  eq       P |= P = true .
  eq     {R} |= P = {noContext | R : noSubstitution} |= P .
  eq {R : S} |= P =    {noContext | R : S} |= P .
  eq {C | R} |= P =         {C | R : noSubstitution} |= P .
---)
endfm

--- should be included by a system module
fmod SPATIAL-ACTION-PATTERN is
  including ACTION-SATISFACTION .

  sorts ActionPattern .
  subsorts ProofTerm < ActionPattern < Action .

  op top : RuleName -> ActionPattern .
  op top : RuleName StateSubstitution -> ActionPattern .

  vars C : StateContext . var R : RuleName . vars S S' : StateSubstitution . 

  eq {C  | R : S}        |= {R}         = true .
  eq {C  | R : S ; S'}   |= {R : S}     = true .
  eq {C  | R : S}        |= {C | R}     = true .
  eq {C  | R : S ; S'}   |= {C | R : S} = true .
  eq {[] | R : S}        |= top(R)      = true .
  eq {[] | R : S ; S'}   |= top(R, S)   = true .
endfm

fmod FAIRNESS is
  including LTL .

--- Fairness conditions
  sorts FairnessSet Fairness FairnessType .
  subsort Fairness < FairnessSet .
  op noFairness : -> FairnessSet [ctor] .
  op _;_ : FairnessSet FairnessSet -> FairnessSet 
	[ctor comm assoc id: noFairness] .
  ops fair just : -> FairnessType . --- strong and weak fairness
  op _:_=>_ : FairnessType Formula Formula -> Fairness [ctor] .

---( ?? if a formula contains a variable, it is considered as a
universally quantified formula

  op []<>_->[]<>_ : Formula Formula -> Fairness [ctor] .
  op <>[]_->[]<>_ : Formula Formula -> Fairness [ctor] .
---)
endfm

--- definable props ( should be generated from |= definitions ).
fmod DEFINABLE-PROPOSITION is
  including SATISFACTION .
  including ACTION-SATISFACTION .
  including LTL .
  subsorts Prop Action < Formula .

  sort DefProp .
  op def? : State Prop ~> DefProp [frozen ctor] .
  op def? : ProofTerm Action ~> DefProp [frozen ctor] .
  op defres : Formula ~> DefProp [ctor] .

  --- NOTE: the left side of the rule cannot have a variable,
  --- that's why the previous version do not have the parameterized prop
  --- in the left side of the rule...

  --- For each equation "ceq STATE |= PROP = RESULT if COND .",
  --- and a parameterized proposition P that matches PROP, a rule 
  ---  crl def?(STATE, P) => defres(P) if P := PROP /\ COND /\ RESULT .
  --- is defind, where vars(P) does not contains any variable in the equation. 
  --- FULL-Maude interface should generates these rules, 
  --- but more efficient core-Maude implementation would be possible,
  --- though it is quite complex.
endfm

fmod LTLR-MODEL-CHECKER is
  including FAIRNESS .
  including DEFINABLE-PROPOSITION .
  subsort State < StateContext .

  --- "enabled" prop should be also defined for each action.
  op enabled : Action -> Prop .

  --- each fair formula is reduced to NNF.

---(
--- Param Flags
  sorts FairFlag FairSEFlag FairSWFlag .
  op noParam : -> FairFlag .
  op flag : FairSEFlag FairSWFlag -> FairFlag .
  ops stateParam seParam : -> FairSEFlag .
  ops justParam fairParam jfParam : -> FairSWFlag .
---)

--- counter example
  sorts Transition TransitionList ModelCheckResult .
  subsorts Transition < TransitionList .
  subsorts Bool < ModelCheckResult .

  op {_,_} : State ProofTerm -> Transition [ctor format (n s d i s d)] .
  op nil : -> TransitionList [ctor] .
  op __ : TransitionList TransitionList -> TransitionList [ctor assoc id: nil] .
  op counterexample : TransitionList TransitionList -> ModelCheckResult [ctor] .

--- model checker

  --- default model checker with no fairness
  op modelCheck : State Formula ~> ModelCheckResult .
  eq modelCheck(S:State, F:Formula)
   = modelCheckFair(S:State, F:Formula, noFairness) .

  --- definable predicate symbols.. internally used to generate rules..
  op def? : State -> Prop .
  op def? : ProofTerm -> Action .

  --- basic function
  --- args: initial states, LTLR formula, (ground) Fairness, param Flag 
  op modelCheckFair : State Formula FairnessSet ~> ModelCheckResult
        [special (
           id-hook LTLRFairnessCheckerSymbol

	   --- state/event temporal
           op-hook trueSymbol              (True : ~> Formula)
           op-hook falseSymbol             (False : ~> Formula)
           op-hook notSymbol               (~_ : Formula ~> Formula)
           op-hook nextSymbol              (O_ : Formula ~> Formula)
           op-hook andSymbol               (_/\_ : Formula Formula ~> Formula)
           op-hook orSymbol                (_\/_ : Formula Formula ~> Formula)
           op-hook untilSymbol             (_U_ : Formula Formula ~> Formula)
           op-hook releaseSymbol           (_R_ : Formula Formula ~> Formula)

	   --- proofterm
           op-hook prooftermSymbol         ({_|_:_} : StateContext RuleName StateSubstitution ~> ProofTerm)
	   op-hook substitutionSymbol      (_;_ : StateSubstitution StateSubstitution ~> StateSubstitution)
	   op-hook emptySubstSymbol        (noSubstitution : ~> StateSubstitution)
	   op-hook qidSymbol               (<Qids> : ~> Qid)
	   op-hook unlabeledSymbol         (unlabeled : ~> RuleName)
	   op-hook noContextSymbol         (noContext : ~> StateContext)
           term-hook deadlockTerm          (deadlock)
           
	   --- labeling
           op-hook satisfiesSymbol         (_|=_ : State Formula ~> Bool)
           op-hook actionmatchSymbol       (_|=_ : ProofTerm Formula ~> Bool)
           op-hook tauSymbol               (tau : ~> Action)
           term-hook trueTerm              (true)

           --- counter example
           term-hook falseTerm             (false)
	   op-hook transitionSymbol        ({_,_} : State ProofTerm ~> Transition)
	   op-hook transitionListSymbol    (__ : TransitionList TransitionList ~> TransitionList)
	   op-hook nilTransitionListSymbol (nil : ~> TransitionList)
           op-hook counterexampleSymbol    (counterexample : TransitionList TransitionList ~> ModelCheckResult)

           --- fairness
	   op-hook fairnessSymbol          (_:_=>_ : FairnessType Formula Formula ~> Fairness)
	   op-hook strongFairTypeSymbol    (fair : ~> FairnessType)
	   op-hook weakFairTypeSymbol      (just : ~> FairnessType)
	   op-hook fairnessSetSymbol       (_;_ : FairnessSet FairnessSet ~> FairnessSet)
	   op-hook emptyFairnessSetSymbol  (noFairness : ~> FairnessSet)

	   --- definable-props
	   op-hook defStateSymbol	   (def? : State ~> Prop)
	   op-hook defEventSymbol	   (def? : ProofTerm ~> Action)
---(
	   --- definable-props
	   op-hook defStateTestSymbol	   (def? : State Prop ~> DefProp)
	   op-hook defEventTestSymbol	   (def? : ProofTerm Action ~> DefProp)
	   op-hook defResultSymbol         (defres : Formula ~> DefProp)

           --- fairness flags
	   op-hook noParamFlagSymbol	   (noParam : ~> FairFlag)
	   op-hook paramFlagSymbol	   (flag : FairSEFlag FairSWFlag ~> FairFlag) 
	   op-hook stateParamFlagSymbol	   (stateParam : ~> FairSEFlag)
	   op-hook seParamFlagSymbol	   (seParam : ~> FairSEFlag)
	   op-hook justParamFlagSymbol	   (justParam : ~> FairSWFlag)
	   op-hook fairParamFlagSymbol	   (fairParam : ~> FairSWFlag)
	   op-hook jfParamFlagSymbol	   (jfParam : ~> FairSWFlag)
---)
         )] .
endfm

fmod RULENAME-COUNTEREXAMPLE is
  including LTLR-MODEL-CHECKER .

  eq {S:State, {C:StateContext | R:RuleName : S:StateSubstitution}} 
   = {S:State, {R:RuleName}} .

endfm

fmod SIMPLEPROOF-COUNTEREXAMPLE is
  including LTLR-MODEL-CHECKER .

  eq {S:State, {C:StateContext | R:RuleName : S:StateSubstitution}} 
   = {S:State, {R:RuleName : S:StateSubstitution}} .
endfm
