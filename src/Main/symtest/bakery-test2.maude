set include BOOL off .

mod BAKERY-SATISFACTION2-ABS is
  sorts Bool CEAssignment CESubstitution Char Conf FindResult Formula Mode
    ModeCrit ModeIdle ModeWait ModelCheckResult Name Nat NzNat Proc ProcIdle
    ProcIdleSet ProcSet ProcWait ProcWaitSet Prop Qid RuleName State String
    Transition TransitionList Zero .
  subsort Bool < ModelCheckResult .
  subsort CEAssignment < CESubstitution .
  subsort Char < String .
  subsort Conf < State .
  subsort ModeCrit < Mode .
  subsort ModeIdle < Mode .
  subsort ModeWait < Mode .
  subsort Nat < FindResult .
  subsort NzNat < Nat .
  subsort Proc < ProcSet .
  subsort ProcIdle < Proc .
  subsort ProcIdle < ProcIdleSet .
  subsort ProcIdleSet < ProcWaitSet .
  subsort ProcWait < Proc .
  subsort ProcWait < ProcWaitSet .
  subsort ProcWaitSet < ProcSet .
  subsort Prop < Formula .
  subsort Qid < RuleName .
  subsort Transition < TransitionList .
  subsort Zero < Nat .
  op _;_;_ : Name Name ProcSet -> Conf .
  op `[_`] : Mode -> Proc .
  op `[_`] : ModeIdle -> ProcIdle .
  op `[_`] : ModeWait -> ProcWait .
  op crit : Name -> ModeCrit .
  op deadlock : -> RuleName .
  op ex? : -> Prop .
  op idle : -> ModeIdle .
  op ini : -> Prop .
  op none : -> CESubstitution .
  op none : -> ProcIdleSet .
  op unlabeled : -> RuleName .
  op wait : Name -> ModeWait .
  op 0 : -> Name
    [ctor] .
  op 0 : -> Zero
    [ctor] .
  op <>_ : Formula -> Formula
    [prec 53 format(r o d)] .
  op <Qids> : -> Qid
    [special(id-hook QuotedIdentifierSymbol)] .
  op <Strings> : -> Char
    [special(id-hook StringSymbol)] .
  op <Strings> : -> String
    [special(id-hook StringSymbol)] .
  op False : -> Formula
    [format(g o)ctor] .
  op O_ : Formula -> Formula
    [prec 53 format(r o d)ctor] .
  op True : -> Formula
    [format(g o)ctor] .
  op _&_ : Nat Nat -> Nat
    [assoc comm prec 53 special(id-hook ACU_NumberOpSymbol(&)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : Nat Nat -> Nat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _*_ : NzNat NzNat -> NzNat
    [assoc comm prec 31 special(id-hook ACU_NumberOpSymbol(*)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : Nat Nat -> Nat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : NzNat Nat -> NzNat
    [assoc comm prec 33 special(id-hook ACU_NumberOpSymbol(+)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _+_ : String String -> String
    [prec 33 gather(E e)special(id-hook StringOpSymbol(+)op-hook stringSymbol(
    <Strings> : ~> Char))] .
  op _->_ : Formula Formula -> Formula
    [prec 65 gather(e E)format(d r o d)] .
  op _/\_ : Formula Formula -> Formula
    [comm prec 55 gather(E e)format(d r o d)ctor] .
  op _;_ : CESubstitution CESubstitution -> CESubstitution
    [assoc comm id:(none).CESubstitution prec 65 ctor] .
  op _<->_ : Formula Formula -> Formula
    [prec 65 format(d r o d)] .
  op _<-_ : Qid Universal -> CEAssignment
    [poly(2)prec 63 ctor] .
  op _<<_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(<<)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _<=>_ : Formula Formula -> Formula
    [prec 65 format(d r o d)] .
  op _<=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<=_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(<=)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(<)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _<_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(<)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _=/=_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    false)term-hook notEqualTerm(true))] .
  op _==_ : Universal Universal -> Bool
    [poly(1 2)prec 51 special(id-hook EqualitySymbol term-hook equalTerm(
    true)term-hook notEqualTerm(false))] .
  op _=>_ : Formula Formula -> Formula
    [prec 65 gather(e E)format(d r o d)] .
  op _>=_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>=)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>=_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(>=)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>>_ : Nat Nat -> Nat
    [prec 35 gather(E e)special(id-hook NumberOpSymbol(>>)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _>_ : Nat Nat -> Bool
    [prec 37 special(id-hook NumberOpSymbol(>)op-hook succSymbol(s_ : Nat ~>
    NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _>_ : String String -> Bool
    [prec 37 special(id-hook StringOpSymbol(>)op-hook stringSymbol(<Strings> :
    ~> Char)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _R_ : Formula Formula -> Formula
    [prec 63 format(d r o d)ctor] .
  op _U_ : Formula Formula -> Formula
    [prec 63 format(d r o d)ctor] .
  op _W_ : Formula Formula -> Formula
    [prec 63 format(d r o d)] .
  op _\/_ : Formula Formula -> Formula
    [comm prec 59 gather(E e)format(d r o d)ctor] .
  op _^_ : Nat Nat -> Nat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op _^_ : NzNat Nat -> NzNat
    [prec 29 gather(E e)special(id-hook NumberOpSymbol(^)op-hook succSymbol(s_
    : Nat ~> NzNat))] .
  op __ : Name Name -> Name
    [assoc comm id:(0).Name ctor] .
  op __ : ProcIdleSet ProcIdleSet -> ProcIdleSet
    [assoc comm id:(none).ProcIdleSet] .
  op __ : ProcSet ProcSet -> ProcSet
    [assoc comm id:(none).ProcIdleSet] .
  op __ : ProcWaitSet ProcWaitSet -> ProcWaitSet
    [assoc comm id:(none).ProcIdleSet] .
  op __ : TransitionList TransitionList -> TransitionList
    [assoc id: nil format(d ni d)ctor] .
  op _and_ : Bool Bool -> Bool
    [assoc comm prec 55] .
  op _divides_ : NzNat Nat -> Bool
    [prec 51 special(id-hook NumberOpSymbol(divides)op-hook succSymbol(s_ : Nat
    ~> NzNat)term-hook trueTerm(true)term-hook falseTerm(false))] .
  op _implies_ : Bool Bool -> Bool
    [prec 61 gather(e E)] .
  op _or_ : Bool Bool -> Bool
    [assoc comm prec 59] .
  op _quo_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(quo)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _rem_ : Nat NzNat -> Nat
    [prec 31 gather(E e)special(id-hook NumberOpSymbol(rem)op-hook succSymbol(
    s_ : Nat ~> NzNat))] .
  op _xor_ : Bool Bool -> Bool
    [assoc comm prec 57] .
  op _xor_ : Nat Nat -> Nat
    [assoc comm prec 55 special(id-hook ACU_NumberOpSymbol(xor)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|->_ : Formula Formula -> Formula
    [prec 63 format(d r o d)] .
  op _|=_ : State Prop -> Bool
    [frozen(1 2)] .
  op _|_ : Nat Nat -> Nat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op _|_ : NzNat Nat -> NzNat
    [assoc comm prec 57 special(id-hook ACU_NumberOpSymbol(|)op-hook
    succSymbol(s_ : Nat ~> NzNat))] .
  op `[`]_ : Formula -> Formula
    [prec 53 format(r d o d)] .
  op `{_`,_`,_`} : State CESubstitution RuleName -> Transition
    [ctor] .
  op ascii : Char -> Nat
    [special(id-hook StringOpSymbol(ascii)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op char :[FindResult]->[String]
    [special(id-hook StringOpSymbol(char)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op false : -> Bool
    [ctor special(id-hook SystemFalse)] .
  op find : String String Nat -> FindResult
    [special(id-hook StringOpSymbol(find)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat)term-hook notFoundTerm(
    notFound))] .
  op gcd : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op gcd : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(gcd)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op if_then_else_fi : Bool Universal Universal -> Universal
    [poly(2 3 0)special(id-hook BranchSymbol term-hook 1(true)term-hook 2(
    false))] .
  op lcm : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op lcm : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(lcm)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op length : String -> Nat
    [special(id-hook StringOpSymbol(length)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op max : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op max : NzNat Nat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(max)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : Nat Nat -> Nat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op min : NzNat NzNat -> NzNat
    [assoc comm special(id-hook ACU_NumberOpSymbol(min)op-hook succSymbol(s_ :
    Nat ~> NzNat))] .
  op modExp :[Nat][Nat][Nat]->[Nat]
    [special(id-hook NumberOpSymbol(modExp)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op nil : -> TransitionList
    [ctor] .
  op notFound : -> FindResult
    [ctor] .
  op not_ : Bool -> Bool
    [prec 53] .
  op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult
    [format(n n++i n ni i--)ctor] .
  op qid :[String]->[Qid]
    [special(id-hook QuotedIdentifierOpSymbol(qid)op-hook
    quotedIdentifierSymbol(<Qids> : ~> Qid)op-hook stringSymbol(<Strings> : ~>
    Char))] .
  op rfind : String String Nat -> FindResult
    [special(id-hook StringOpSymbol(rfind)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat)term-hook notFoundTerm(
    notFound))] .
  op s : -> Name
    [ctor] .
  op s_ : Nat -> NzNat
    [ctor iter special(id-hook SuccSymbol term-hook zeroTerm((0).Zero))] .
  op sd : Nat Nat -> Nat
    [comm special(id-hook CUI_NumberOpSymbol(sd)op-hook succSymbol(s_ : Nat ~>
    NzNat))] .
  op string : Qid -> String
    [special(id-hook QuotedIdentifierOpSymbol(string)op-hook
    quotedIdentifierSymbol(<Qids> : ~> Qid)op-hook stringSymbol(<Strings> : ~>
    Char))] .
  op substr : String Nat Nat -> String
    [special(id-hook StringOpSymbol(substr)op-hook stringSymbol(<Strings> : ~>
    Char)op-hook succSymbol(s_ : Nat ~> NzNat))] .
  op true : -> Bool
    [ctor special(id-hook SystemTrue)] .
  op ~_ : Formula -> Formula
    [prec 53 format(r o d)ctor] .
  eq <> f:Formula
    = True U f:Formula .
  eq f:Formula -> g:Formula
    = g:Formula \/ ~ f:Formula .
  eq CA:CEAssignment ; CA:CEAssignment
    = CA:CEAssignment .
  eq f:Formula <-> g:Formula
    = (g:Formula -> f:Formula)/\(f:Formula -> g:Formula) .
  eq f:Formula <=> g:Formula
    = [](f:Formula <-> g:Formula) .
  eq f:Formula => g:Formula
    = [](f:Formula -> g:Formula) .
  eq f:Formula W g:Formula
    = []f:Formula \/(f:Formula U g:Formula) .
  eq A:Bool and A:Bool
    = A:Bool .
  eq A:Bool and(B:Bool xor C:Bool)
    = A:Bool and B:Bool xor A:Bool and C:Bool .
  eq false and A:Bool
    = false .
  eq true and A:Bool
    = A:Bool .
  eq A:Bool implies B:Bool
    = not(A:Bool xor A:Bool and B:Bool) .
  eq A:Bool or B:Bool
    = A:Bool and B:Bool xor A:Bool xor B:Bool .
  eq A:Bool xor A:Bool
    = false .
  eq false xor A:Bool
    = A:Bool .
  eq f:Formula |-> g:Formula
    = [](f:Formula -> <> g:Formula) .
  eq []f:Formula
    = False R f:Formula .
  eq not A:Bool
    = true xor A:Bool .
  eq ~ False
    = True .
  eq ~ True
    = False .
  eq ~ O f:Formula
    = O ~ f:Formula .
  eq ~(g:Formula /\ f:Formula)
    = ~ g:Formula \/ ~ f:Formula .
  eq ~(f:Formula R g:Formula)
    = ~ f:Formula U ~ g:Formula .
  eq ~(f:Formula U g:Formula)
    = ~ f:Formula R ~ g:Formula .
  eq ~(g:Formula \/ f:Formula)
    = ~ g:Formula /\ ~ f:Formula .
  eq ~ ~ f:Formula
    = f:Formula .
  eq (s s s N:Name M:Name); M:Name ; IS:ProcIdleSet[crit(L:Name)][wait(N:Name
    M:Name)][wait(s N:Name M:Name)][wait(s s N:Name M:Name)]
    = (s s N:Name M:Name); M:Name ; IS:ProcIdleSet[crit(L:Name)][wait(N:Name
    M:Name)][wait(s N:Name M:Name)] [variant] .
  eq (s s s N:Name M:Name); M:Name ; IS:ProcIdleSet[wait(N:Name M:Name)][wait(s
    N:Name M:Name)][wait(s s N:Name M:Name)]
    = (s s N:Name M:Name); M:Name ; IS:ProcIdleSet[wait(N:Name M:Name)][wait(s
    N:Name M:Name)] [variant] .
  eq N:Name ; M:Name ; WS:ProcWaitSet |= ex?
    = true [variant] .
  eq N:Name ; M:Name ;[crit(M1:Name)]WS:ProcWaitSet |= ex?
    = true [variant] .
  eq N:Name ; M:Name ;[crit(M1:Name)][crit(M2:Name)]PS:ProcSet |= ex?
    = false [variant] .
  rl N:Name ; M:Name ; PS:ProcSet[idle]
    => (s N:Name); M:Name ; PS:ProcSet[wait(N:Name)] [label wake] .
  rl N:Name ; M:Name ; PS:ProcSet[crit(M:Name)]
    => N:Name ; s M:Name ; PS:ProcSet[idle] [label exit] .
  rl N:Name ; M:Name ; PS:ProcSet[wait(M:Name)]
    => N:Name ; M:Name ; PS:ProcSet[crit(M:Name)] [label crit] .
endm
