
fmod UNORDERED-CHANNEL-EQ is
  vars N M J K : Nat2 .      vars L P Q : List .

--- Nat2
  sort Nat2 .
  op 0 : -> Nat2 [ctor] .
  op s : Nat2 -> Nat2 [ctor] .

--- list
  sort List .
  op nil : -> List [ctor] .
  op _;_ : Nat2 List -> List [ctor] .   *** list constructor
  op _@_ : List List -> List .      *** list append

  --- the following equations can be problematic for narrowing-based 
  --- model checking... FVP?
  eq nil @ L = L .
  eq (N ; L) @ P = N ; (L @ P) . 

--- conf
  sort Conf .
  op null : -> Conf [ctor] .
  op __ : Conf Conf -> Conf [ctor assoc comm id: null] .

--- msg
  sort Msg .
  subsort Msg < Conf .
  op [_,_] : Nat2 Nat2 -> Msg [ctor] .
  op ack : Nat2 -> Msg [ctor] .

--- state
  sort ChannelState .
  op {_,_|_|_,_} : List Nat2 Conf List Nat2 -> ChannelState [ctor] .
endfm

mod UNORDERED-CHANNEL is
  pr UNORDERED-CHANNEL-EQ .
  vars N M J K : Nat2 .      vars L P Q : List .  var  C : Conf .

  rl [snd]: {N ; L, M | C | P, K} => {N ; L, M | [N, M] C | P, K} .
  rl [rec]: {L, M | [N, J] C | P, J}  
    => {L, M | ack(J) C | P @ (N ; nil), s(J)}  .
  rl [rec-ack]: {N ; L, J | ack(J) C | P, M}  => {L, s(J) | C | P, M} .
endm

load symbolic-checker

(mod UNORDERED-CHANNEL-PREDS is
  protecting UNORDERED-CHANNEL .
  protecting SYMBOLIC-CHECKER .

  vars M N K P : Nat2 . vars L L' L'' : List . var  C : Conf . var  B : Bool . 

  subsort ChannelState < State .

  op prefix : List -> Prop .
  eq {L', N | C | K ; L'', P} |= prefix(M ; L) 
   = (M == K) and ({L', N | C | L'', P} |=  prefix(L)) [variant] .
  eq {L', N | C | nil, K} |=  prefix(L) = true [variant] .
  eq {L', N | C | M ; L'', K} |=  prefix(nil) = false [variant] .
endm)

--- not work well,,, due to the variable in the formula, and
--- the equation for the list concatenation
(smc {L:List, N:Nat2 | C:Conf | nil, P:Nat2} |= [] prefix(L:List) .)

