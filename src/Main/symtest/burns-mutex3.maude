
--- The Burns's mutual exclusion algorithms in Maude
--- From: Nancy Ann Lynch, Distributed algorithms, Morgan Kaufmann, 1996
---
---    repeat
---l1:   flag[i] := 0
---l2:   if EXIST j<i: flag[j] = 1 then goto l1
---l3:   flag[i] := 1
---l4:   if EXIST j<i: flag[j] = 1 then goto l1
---l5:   awiat ALL j>i : flag[j] != 1
---crit:
---l6:   flag[i] := 0
---    forever

fmod NUMBERS is
  sort Number .
  op 0 : -> Number [ctor] .
  op s : -> Number [ctor] .
  op __ : Number Number -> Number [ctor comm assoc id: 0] .
endfm

fmod BURNS-DATA is
  sorts Status WaitStatus InitStatus .
  subsorts InitStatus < WaitStatus < Status .
  op l1 : -> InitStatus [ctor] .
  ops l2 l3 l4 l5 : -> WaitStatus [ctor] .
  op crit : -> Status [ctor] .

  sorts Flag Flag0 .
  subsorts Flag0 < Flag .
  op 0 : -> Flag0 [ctor] .
  op 1 : -> Flag [ctor] .
endfm

fmod BURNS-PROCS is
  protecting NUMBERS .
  protecting BURNS-DATA .

  sort Proc .
  op [_:_,_] : Number Flag Status -> Proc [ctor] .

  sorts Flag0Proc WaitProc InitProc .
  subsorts Flag0Proc < Proc .
  subsorts InitProc < WaitProc < Proc .
  op [_:_,_] : Number Flag0 Status -> Flag0Proc [ctor] .
  op [_:_,_] : Number Flag WaitStatus -> WaitProc [ctor] .
  op [_:_,_] : Number Flag InitStatus -> InitProc [ctor] .

  sorts WaitFlag0Proc InitFlag0Proc .
  subsorts InitFlag0Proc < WaitFlag0Proc InitProc .
  subsorts WaitFlag0Proc < WaitProc Flag0Proc .
  op [_:_,_] : Number Flag0 InitStatus -> InitFlag0Proc [ctor] .
  op [_:_,_] : Number Flag0 WaitStatus -> WaitFlag0Proc [ctor] .
endfm

fmod BURNS-PROCSETS is
  protecting BURNS-PROCS .

  sorts ProcSet WaitProcSet InitProcSet Flag0ProcSet .
  subsorts Proc < ProcSet .
  subsorts WaitProc < WaitProcSet .
  subsorts InitProc < InitProcSet .
  subsorts Flag0Proc < Flag0ProcSet .
  subsorts InitProcSet < WaitProcSet < ProcSet .
  subsorts Flag0ProcSet < ProcSet .
  op none : -> InitFlag0ProcSet [ctor] .
  op __ : ProcSet ProcSet -> ProcSet [ctor comm assoc id: none] .
  op __ : WaitProcSet WaitProcSet -> WaitProcSet [ctor ditto] .
  op __ : InitProcSet InitProcSet -> InitProcSet [ctor ditto] .
  op __ : Flag0ProcSet Flag0ProcSet -> Flag0ProcSet [ctor ditto] .

  sorts WaitFlag0ProcSet InitFlag0ProcSet .
  subsorts WaitFlag0Proc < WaitFlag0ProcSet < WaitProcSet Flag0ProcSet .
  subsorts InitFlag0Proc < InitFlag0ProcSet < InitProcSet Flag0ProcSet .
  subsorts InitFlag0ProcSet < WaitFlag0ProcSet .
  op __ : WaitFlag0ProcSet WaitFlag0ProcSet -> WaitFlag0ProcSet [ctor ditto] .
  op __ : InitFlag0ProcSet InitFlag0ProcSet -> InitFlag0ProcSet [ctor ditto] .
endfm

mod BURNS-CONF is
  protecting BURNS-PROCSETS .

  sort Conf .
  op <_> : ProcSet -> Conf [ctor] .
  op <_> : ProcSetTriple -> Conf [ctor] .

  sort ProcSetTriple .
  op _|_|_ : Proc ProcSet ProcSet -> ProcSetTriple [ctor] .
endm

mod BURNS-MUTEX is
  protecting BURNS-CONF .

  vars I J : Number . vars F G : Flag . var S : Status .
  var P : Proc . vars PS PS' : ProcSet . var F0PS : Flag0ProcSet .


  rl [l1]  : < [I : F,l1] PS >
          => < [I : 0,l2] PS > .

---
  rl [pl2] : < [I : F,l2] PS >  
          => < [I : F,l2] | PS | none > .

  rl [bl2] : < [I : F,l2] | PS | PS' >
          => < [I : F,l2] PS PS' > .

  rl [cl2] : < [I : F,l2] | [I J : G,S] PS | PS' >
         =>  < [I : F,l2] | PS | [I J : G,S] PS' > .

  rl [l2a] : < [s J I : F,l2] | [J : 1,S] PS | PS' >
          => < [s J I : F,l1] [J : 1,S] PS PS' > .

  rl [l2b] : < [I : F,l2] | F0PS | PS >
          => < [I : F,l3] F0PS PS > .  

---
  rl [l3] : < [I : F,l3] PS >
         => < [I : 1,l4] PS > .

---
  rl [pl4] : < [I : F,l4] PS >  
          => < [I : F,l4] | PS | none > . 

  rl [bl4] : < [I : F,l4] | PS | PS' >
          => < [I : F,l4] PS PS' > .

  rl [cl4] : < [I : F,l4] | [I J : G,S] PS | PS' >
         =>  < [I : F,l4] | PS | [I J : G,S] PS' > .

  rl [l4a] : < [s J I : F,l4] | [J : 1,S] PS | PS' >
          => < [s J I : F,l1] [J : 1,S] PS PS' > .

  rl [l4b] : < [I : F,l4] | F0PS | PS >
          => < [I : F,l5] F0PS PS > .    

---
  rl [pl5] : < [I : F,l5] PS >
          => < [I : F,l5] | none | PS > . 

  rl [bl5] : < [I : F,l5] | PS | PS' >
          => < [I : F,l5] PS PS' > .

  rl [cl5] : < [s I J : F,l5] | PS | PS' [J : G,S] >
          => < [s I J : F,l5] | PS [J : G,S] | PS' > .

  rl [l5a] : < [I : F,l5] | PS | PS' [s J I : 1,S] >
          => < [I : F,l5] PS PS' [s J I : 1,S] > .

  rl [l5b] : < [I : F,l5] | PS | F0PS > 
          => < [I : F,crit] PS F0PS > .

---
  rl [l6] : < [I : F,crit] PS >
         => < [I : 0,l1] PS > .
endm

--- search < [0 : 0,l1] [s : 0,l1] [s s : 0,l1] > =>* < PS > .

load symbolic-checker-core .


(mod BURNS-MUTEX-SATISFACTION is
  pr SYMBOLIC-CHECKER .
  pr BURNS-MUTEX .

  subsort Conf < State .

  ops ex? : -> Prop . 

  var I J : Number . vars F G : Flag . var S : Status . 
  var P : Proc . var WP : WaitProc .
  vars WS WS' : WaitProcSet . vars PS PS' : ProcSet .

  eq < WS >                           |= ex? = true  [variant] .
  eq < [I : F,crit] WS >              |= ex? = true  [variant] .
  eq < [I : F,crit] [J : G,crit] PS > |= ex? = false [variant] .

  eq < WP | WS | WS' >                          |= ex? = true [variant] .
  eq < [I : F,crit] | WS | WS' >                |= ex? = true [variant] .
  eq < WP | [I : F,crit] WS | WS' >             |= ex? = true [variant] .
  eq < WP | WS | [I : F,crit] WS' >             |= ex? = true [variant] .
  eq < [I : F,crit] | [J : G,crit] PS | PS' >   |= ex? = false [variant] .
  eq < [I : F,crit] | PS | [J : G,crit] PS' >   |= ex? = false [variant] .
  eq < P | [I : F,crit] [J : G,crit] PS | PS' > |= ex? = false [variant] .
  eq < P | [I : F,crit] PS | [J : G,crit] PS' > |= ex? = false [variant] .
  eq < P | PS | [I : F,crit] [J : G,crit] PS' > |= ex? = false [variant] .

endm)

---(
(lfmc [20] < IS:InitProcSet > |= [] ex? .)
---)

(mod BURNS-MUTEX-SATISFACTION-ABS is
  pr BURNS-MUTEX-SATISFACTION .

  vars I J K : Number . vars F G : Flag . 
  vars S S' : Status .
  var P : Proc .  var IS : InitProcSet . vars PS PS' : ProcSet .  

--- it seems that all reachable instances have the FIP.
--- also, it is somewhat necessary to have such equations, for possibly, unification?
  eq < PS [I : 0,l2] [J : 0,l2] > = < PS [I : 0,l2] > [variant] .
  eq < PS [I : 0,l3] [J : 0,l3] > = < PS [I : 0,l3] > [variant] .
  eq < PS [I : 1,l4] [J : 1,l4] > = < PS [I : 1,l4] > [variant] .

  eq < [K : 0,l2] | PS | [I : F,S] [J : G,S'] > 
   = < [K : 0,l2] | PS | [I : F,S] > [variant] .
  eq < [K : 1,l4] | PS | [I : F,S] [J : G,S'] > 
   = < [K : 1,l4] | PS | [I : F,S] > [variant] .
  eq < [K : 1,l5] | [I : F,S] [J : G,S'] | PS > 
   = < [K : 1,l5] | [I : F,S] | PS > [variant] .
endm)

(lfmc < IS:InitProcSet > |= [] ex? .)

