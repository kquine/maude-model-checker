load symbolic-checker

--- Lamport's Bakery protocol in Maude.
--- From: All About Maude - A High-Performance Logical Framework. 
(fmod BAKERY-SYNTAX is 
  sort Nat .
  op 0 : -> Nat [ctor] .
  op s : Nat -> Nat [ctor] .

  sorts ModeIdle ModeWait ModeCrit Mode . 
  subsorts ModeIdle ModeWait ModeCrit < Mode . 
  sorts ProcIdle ProcWait Proc ProcIdleSet ProcWaitSet ProcSet . 
  subsorts ProcIdle < ProcIdleSet . 
  subsorts ProcWait < ProcWaitSet . 
  subsorts ProcIdle ProcWait < Proc < ProcSet . 
  subsorts ProcIdleSet < ProcWaitSet < ProcSet . 
  
  op idle : -> ModeIdle . 
  op wait : Nat -> ModeWait . 
  op crit : Nat -> ModeCrit . 
  op `[_`,_`] : Nat ModeIdle -> ProcIdle . 
  op `[_`,_`] : Nat ModeWait -> ProcWait . 
  op `[_`,_`] : Nat Mode -> Proc . 
  op none : -> ProcIdleSet . 
  op __ : ProcIdleSet ProcIdleSet -> ProcIdleSet [assoc comm id: none] . 
  op __ : ProcWaitSet ProcWaitSet -> ProcWaitSet [assoc comm id: none] .
  op __ : ProcSet ProcSet -> ProcSet [assoc comm id: none] .

  sort Conf . 
  op _;_;_ : Nat Nat ProcSet -> Conf .
endfm)

(mod BAKERY is
  protecting BAKERY-SYNTAX . 
  
  var PS : ProcSet .  vars N M K : Nat . 
  
  rl [wake] : N ; M ; [K, idle] PS => s(N) ; M ; [K, wait(N)] PS .
  rl [crit] : N ; M ; [K, wait(M)] PS => N ; M ; [K, crit(M)] PS .
  rl [exit] : N ; M ; [K, crit(M)] PS => N ; s(M) ; [K, idle] PS .
endm)

--- Mutual exclusion proposition specification.
--- The sort Nat in SYMBOLIC-CHECKER is renamed to Nat' to avoid
--- the sort name confliction.
(mod BAKERY-SAFETY-SATISFACTION is
  pr BAKERY .
  pr SYMBOLIC-CHECKER * (sort Nat to Nat') .

  subsort Conf < State .

  op ex? : -> Prop . 

  var WS : ProcWaitSet . var PS : ProcSet . 
  vars N M K M1 M2 K1 K2 : Nat .

  eq N ; M ; WS |= ex? = true [variant] .
  eq N ; M ; [K1, crit(M1)] WS |= ex? = true [variant] .
  eq N ; M ; [K1, crit(M1)] [K2, crit(M2)] PS |= ex? = false [variant] .
endm)

--- the model checking command with the bound 10 (renaming equivalence)
--- result: no counterexample
(lmc [10] N:Nat ; N:Nat ; [0, idle] [s(0), idle] |= [] ex? .)

--- the folding model checking command 
--- result: true
(lfmc N:Nat ; N:Nat ; [0, idle] [s(0), idle] |= [] ex? .)

--- the folding model checking command with the bound 15
--- no counterexample
(lfmc [15] N:Nat ; N:Nat ; IS:ProcIdleSet  |= [] ex? .)

*** the following command takes several minutes...
*** (lfmc [50] N:Nat ; N:Nat ; IS:ProcIdleSet  |= [] ex? .)

--- false (with a counterexample)
(lmc N:Nat ; N:Nat ; [0, idle] [s(0), idle] |= O []~ ex? .)

--- false (with a counterexample)
(lfmc N:Nat ; N:Nat ; [0, idle] [s(0), idle] |= O []~ ex? .)

--- possibly spurious counterexample
(lfmc N:Nat ; N:Nat ; [0, idle] [s(0), idle] |= <> ~ ex? .)

--- The proposition specification for a liveness property
(mod BAKERY-LIVENESS-SATISFACTION is
  pr BAKERY .
  pr SYMBOLIC-CHECKER * (sort Nat to Nat') .

  subsort Conf < State .

  ops ever-wait? ever-crit? : -> Prop . 

  vars N M : Nat . vars PS : ProcSet . 
  
  eq s(N) ; M ; PS |= ever-wait? = true [variant] . 
  eq 0 ; M ; PS    |= ever-wait? = false [variant] . 
  eq N ; s(M) ; PS |= ever-crit? = true [variant] .
  eq N ; 0 ; PS    |= ever-crit? = false [variant] . 
endm)

--- true
(lfmc N ; N ; [0, idle] [s(0), idle] |= [] (ever-wait? -> <> ever-crit?) .)

--- false (counterexample)
(lfmc N ; N ; [0, idle] [s(0), idle] |= [] (ever-wait? -> ever-crit?) .)

*** possibly spurious counterexample
(lfmc N ; M ; WS:ProcWaitSet |= [] (ever-wait? -> <> ever-crit?) .)

*** false (deadlock counterexample)
(lfmc N ; M ; IS:ProcIdleSet |= [] (ever-wait? -> <> ever-crit?) .)

