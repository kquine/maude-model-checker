
fmod DINING-PHILOSOPHERS-FUNCS is
  protecting NAT .
  sorts Status .    ops think wait0 wait1 eat : -> Status [ctor] .
  op #N : ~> Nat .  --- a total number of philosophers
  ops lc rc : Nat ~> Nat .    
  op adj : Nat Nat ~> Bool .
  vars I J : Nat .  ceq rc(I) = s(I) if (s(I) < #N) = true .
  eq lc(I) = I .    ceq rc(I) = 0 if (s(I) == #N) = true .
  eq adj(I,J) = (J == lc(I)) or (J == rc(I)) .
endfm

mod DINING-PHILOSOPHERS is
  including DINING-PHILOSOPHERS-FUNCS .
  sorts Philo Chopstick Conf .
  subsorts Philo Chopstick < Conf .   
  op p : Nat Status -> Philo [ctor] .
  op c : Nat -> Chopstick [ctor] .    op none : -> Conf [ctor] .
  op _||_ : Conf Conf -> Conf [ctor comm assoc id: none] .
  eq #N = s(s(0)) . vars I J : Nat .	var C : Conf .	
  
  *** defining the system behavior
  rl [wake]: p(I,think) => p(I,wait0) .
 crl [grabF]: p(I,wait0) || c(J) => p(I,wait1) if adj(I,J) = true .
 crl [grabS]: p(I,wait1) || c(J) => p(I,eat) if adj(I,J) = true .
  rl [stop]: p(I,eat) => p(I,think) || c(lc(I)) || c(rc(I)) .
endm

load ltlr-checker.maude  

mod DINING-PHILOSOPHERS-PROP is
  protecting DINING-PHILOSOPHERS .
  including LTLR-MODEL-CHECKER .
  including SPATIAL-ACTION-PATTERN-EQS .
  subsort Conf < State .
  var CF : Conf .	vars I : Nat .

  op init : -> State .
  eq init = p(0,think) || c(0) || p(1,think) || c(1) .
  op eating : Nat -> Prop [ctor] .
  eq p(I,eat) || CF |= eating(I) = true .
endm

set verbose on .

red modelCheck(init, <> eating(0)) .

red modelCheck(init, [] ~ deadlock) .

red modelCheck(init, [] ~ enabled(deadlock)) .

red modelCheck(init, ([] ~ deadlock) -> <> eating(0)) .



red modelCheck(init,
    (
      ([]<> enabled({'grabF : 'I \ 0}) -> []<> {'grabF : 'I \ 0}) 
    ) 
    -> <> eating(0)) .

red modelCheck(init,
    (
      (<>[] enabled({'wake : 'I \ 0}) -> []<> {'wake : 'I \ 0}) /\
      ([]<> enabled({'grabF : 'I \ 0}) -> []<> {'grabF : 'I \ 0}) 
    ) 
    -> (<> eating(0))) .

red modelCheck(init,
    (
      (<>[] enabled({'wake : 'I \ 0}) -> []<> {'wake : 'I \ 0}) /\
      ([]<> enabled({'grabF : 'I \ 0}) -> []<> {'grabF : 'I \ 0}) 
    ) 
    -> (([] ~ deadlock) -> <> eating(0))) .


red modelCheckFair(init, <> eating(0), 
    just({'wake : 'I \ I:Nat}) ; fair({'grabF : 'I \ I:Nat}) ; fair({'grabS : 'I \ I:Nat})) .

red modelCheckFair(init, []~ deadlock -> <> eating(0), 
    just({'wake : 'I \ I:Nat}) ; fair({'grabF : 'I \ I:Nat}) ; fair({'grabS : 'I \ I:Nat})) .
