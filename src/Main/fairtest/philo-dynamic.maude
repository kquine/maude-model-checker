
mod PHILO is pr NAT .

  --- philosopher
  sorts Philo Status .
  op ph : Nat Status Nat -> Philo [ctor] .
  ops think hungry : -> Status [ctor] .

  --- chopstick
  sort Chopstick .
  op stk : Nat -> Chopstick [ctor] .

  --- configuration
  sort Conf .
  subsorts Philo Chopstick < Conf .
  op none : -> Conf [ctor] .
  op _;_ : Conf Conf -> Conf [ctor comm assoc id: none] .

  sort Top .
  op <_`,_`,_> : Nat Nat Conf -> Top [ctor] .

  vars P Q N C : Nat .  var I J : NzNat . var CF : Conf .

--- equations
  ops left collatz : Nat -> Nat .
  op right : Nat Nat -> Nat .

  eq left(I) = I .
  eq right(I, N) = s(I rem N) .
  eq collatz(P) = if P rem 2 == 0 then P quo 2 else 3 * P + 1 fi .

--- rules
  rl [wake]: ph(I, think, 0) => ph(I, hungry, 0) . 

  crl [grab]: < P, N, ph(I, hungry, C) ; stk(J) ; CF >
           => < P, N, ph(I, hungry, C + 1) ; CF > 
   if J == left(I) or J == right(I, N) .

  rl [stop]: < P, N, ph(I, hungry, 2) ; CF > 
          => < P, N, ph(I, think, 0) ; stk(left(I)) ; stk(right(I,N)) ; CF > .

  rl [solve]: < s s P, N, ph(I, think, 0) ; CF >
	  =>  < collatz(s s P), N, ph(I, think, 0) ; CF > .

  crl [join]: < P, N, ph(N, think, 0) ; CF > 
           => < P, s N, ph(N, think, 0) ; CF ; ph(s N, think, 0) ; stk(s N) > 
   if (N rem 3 == 0) or (P rem (4 * N) == 0) .

  rl [leave]: < P, s s s N, CF ; ph(s s s N, think, 0) ; stk(s s s N) > 
           => < P, s s N, CF > .
endm

load ltlr-checker

--- the following module defines the state sort for the model checking
--- and extra state predicates.

mod PHILO-CHECK is
  inc PHILO .
  inc LTLR-MODEL-CHECKER .

  subsort Top < State .

  var CXT : StateContext . var SUB : StateSubstitution .
  vars P Q N C : Nat .  var I J : NzNat . var CF : Conf .

  op init : Nat -> Top .
  eq init(P) = < P, 2, ph(1, think, 0) ; stk(1) ; ph(2, think, 0) ; stk(2) > .

  ops wake grab : Nat -> Action .
  eq {CXT | 'wake : 'I \ I ; SUB} |= wake(I) = true .
  eq {CXT | 'grab : 'I \ I ; SUB} |= grab(I) = true .

  op eating : Nat -> Prop [ctor] .
  eq < P, N, ph(I, hungry, 2) ; CF > |= eating(I) = true .

  op num : Top -> Nat .
  eq num(< P, N, CF >) = N .
endm

set verbose on .

red modelCheck(init(6), [] ~ deadlock -> <> eating(1)) .
red modelCheckFair(init(6), [] ~ deadlock -> <> eating(1),
     (just : enabled(wake(I:NzNat)) => wake(I:NzNat)) ;
     (fair : enabled(grab(I:NzNat)) => grab(I:NzNat))
) .

red modelCheck(init(12), [] ~ deadlock -> <> eating(1)) .
red modelCheckFair(init(12), [] ~ deadlock -> <> eating(1), 
     (just : enabled(wake(I:NzNat)) => wake(I:NzNat)) ;
     (fair : enabled(grab(I:NzNat)) => grab(I:NzNat))
) .

red modelCheck(init(871), [] ~ deadlock -> <> eating(1)) .
red modelCheckFair(init(871), [] ~ deadlock -> <> eating(1), 
     (just : enabled(wake(I:NzNat)) => wake(I:NzNat)) ;
     (fair : enabled(grab(I:NzNat)) => grab(I:NzNat))
) .
