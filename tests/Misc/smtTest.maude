set show timing off .

load smt

*** Base theory
fmod TEST-B is
  pr BOOLEAN .
  vars W X Y Z : Boolean .
endfm

check W != X and Y .
check W = X and Y .
check X != tt and X != Y and Y != tt .
check X != tt and X != Y and Y != ff .
check (X xor tt) and (X xor Y) and (Y xor tt) .
check (X xor tt) and (X xor Y) and (Y xor ff) .
check not (X or not X) .
check not(X implies Y implies X) .
check (X ? Y : Z) and (Y implies X) and (Z implies X) .
check (X ? Y : Z) and (Y implies not X) and (Z implies X) .
check X = Y and Y = Z .
check X = Y and Y = Z and Z != X .

*** Theory of integers
fmod TEST-I is
  pr INTEGER .
  vars W X Y Z : Boolean .
  vars I J K L : Integer .
endfm

check I > J and J > K .
check I > J and J > K and K > I .
check I < J and J < K .
check I < J and J < K and K < I .
check I >= J and J >= I .
check I >= J and J >= I and I != J .
check I <= J and J <= I .
check I <= J and J <= I and I != J .

check I = J + K and I > J and I > K .
check I = J + K and I > J + K .
check I = J + K and I > J + K + L .
check I = J - K and I > J + K .
check - I = J - K and I > J + K .
check I != J + K and I > J + K .
check (I > J ? I : J) >= I and (I > J ? I : J) >= J .
check (I > J ? I : J) < I .
check (I > J ? I : J) = I or (I > J ? I : J) = J .
check not((I > J ? I : J) = I or (I > J ? I : J) = J) .
check (I > J ? I : J) != I and (I > J ? I : J) != J .

*** Theory of reals
fmod TEST-R is
  pr REAL .
  vars W X Y Z : Boolean .
  vars P Q R S : Real .
endfm

check P > Q and Q > R .
check P > Q and Q > R and R > P .
check P < Q and Q < R .
check P < Q and Q < R and R < P .
check P >= Q and Q >= P .
check P >= Q and Q >= P and P != Q .
check P <= Q and Q <= P .
check P <= Q and Q <= P and P != Q .

check P = Q + R and P > Q and P > R .
check P = Q + R and P > Q + R .
check P = Q + R and P > Q + R + s .
check P = Q - R and P > Q + R .
check - P = Q - R and P > Q + R .
check P != Q + R and P > Q + R .
check (P > Q ? P : Q) >= P and (P > Q ? P : Q) >= Q .
check (P > Q ? P : Q) < P .
check (P > Q ? P : Q) = P or (P > Q ? P : Q) = Q .
check not((P > Q ? P : Q) = P or (P > Q ? P : Q) = Q) .
check (P > Q ? P : Q) != P and (P > Q ? P : Q) != Q .

*** Theory of reals + integers
fmod TEST-RI is
  pr REAL-INTEGER .
  vars W X Y Z : Boolean .
  vars I J K L : Integer .
  vars P Q R S : Real .
endfm

check isInteger(toReal(I) + toReal(J)) != ff .
check isInteger(toReal(I) + toReal(J)) != tt .
check toInteger(R) + toInteger(P) = toInteger(R + P) .
check not(toInteger(R) + toInteger(P) = toInteger(R + P)) .

check 1/2 < P .
check 1/2 < P and P < 3/4 .
check 1/2 < P and P < 3/4 and isInteger(P) .
check -2 < I .
check -2 < I and -2 * I > -1 .
check -2 < I and -2 * I > -1 and I != -1 .
check -2 < I and -2 * I > -1 and I != -1 and I - I != I .

*** meta-level version
select META-LEVEL .

red metaCheck(['REAL-INTEGER], '_=_['_+_['1.Integer, '1.Integer], '2.Integer]) .

red metaCheck(['REAL-INTEGER], '_=_['_+_['1.Integer, '1.Integer], '3.Integer]) .

fmod META-CHECK is
  pr META-LEVEL .
  pr REAL-INTEGER .
  vars W X Y Z : Boolean .
  vars I J K L : Integer .
  vars P Q R S : Real .
endfm

red metaCheck(['META-CHECK], upTerm((I > J ? I : J) < I)) .
red metaCheck(['META-CHECK], upTerm((I > J ? I : J) > I)) .

red metaCheck(['META-CHECK], upTerm( (I > J ? I : J) = I or (I > J ? I : J) = J  )) .
red metaCheck(['META-CHECK], upTerm( not((I > J ? I : J) = I or (I > J ? I : J) = J ) )) .
red metaCheck(['META-CHECK], upTerm( (I > J ? I : J) != I and (I > J ? I : J) != J )) .
red metaCheck(['META-CHECK], upTerm( (I > J ? I : J) != I or (I > J ? I : J) != J )) .
